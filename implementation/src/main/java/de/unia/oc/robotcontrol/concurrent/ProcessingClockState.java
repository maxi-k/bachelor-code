/* %FILE_TEMPLATE_TEXT% */
package de.unia.oc.robotcontrol.concurrent;

import de.unia.oc.robotcontrol.flow.Flow;
import de.unia.oc.robotcontrol.flow.FlowStrategy;
import de.unia.oc.robotcontrol.flow.Flowable;
import de.unia.oc.robotcontrol.flow.strategy.FlatteningFlowStrategy;
import de.unia.oc.robotcontrol.flow.strategy.MappingFlowStrategy;
import de.unia.oc.robotcontrol.flow.strategy.TimedFlowStrategy;
import org.reactivestreams.Processor;
import org.reactivestreams.Publisher;
import reactor.core.publisher.EmitterProcessor;

import java.util.function.BiFunction;
import java.util.function.Supplier;

/**
 * An implementation of {@link ClockState} which uses a processor
 * to apply the passed {@link TimeProvider} to the {@link FlowStrategy}.
 *
 * @param <T> the input of the resulting {@link FlowStrategy}
 * @param <R> the output of the resulting {@link FlowStrategy}
 */
public class ProcessingClockState<T extends Object, R extends Object>
        implements ClockState<T, R> {

    /**
     * The processor converting Instances of {@link TimeProvider}
     * to longs which are emitted with the time providers interval.
     * ({@link TimeProvider#getTicks()})
     */
    private final Processor<TimeProvider, Long> timerPublisher;
    /**
     * The Strategy generated by this {@link ClockState} which provides
     * a {@link TimedFlowStrategy} to be used in the {@link Clockable}
     * object which uses this.
     */
    private final FlowStrategy<T, R> strategy;

    /**
     * The internally used {@link ClockType}
     */
    private final Clockable.ClockType clockType;

    /**
     * Creates a new {@link ProcessingClockState} instance, which provides a {@link FlowStrategy}
     * that can be used in {@link Clockable} instances to handle the clocking state.
     *
     * @param initialInput a supplier for the initial input, which is used if a tick happens
     *                     on the clock when there has been no input to the {@link Clockable}
     *                     instance to pass to the merging function
     * @param mergingFunction the function used to combine a tick emitted by the Clock with
     *                        the last value from the {@link Clockable} {@link org.reactivestreams.Publisher}
     */
    @SuppressWarnings("initialization")
    private ProcessingClockState(Supplier<T> initialInput, BiFunction<Long, T, R> mergingFunction) {
        this.timerPublisher = Flow.withProcessor(
                EmitterProcessor.create(),
                FlowStrategy.concat(
                        MappingFlowStrategy.create(TimeProvider::getTicks),
                        FlatteningFlowStrategy.create()
                )
        );

        this.strategy = TimedFlowStrategy.createTimed(timerPublisher, initialInput, mergingFunction);
        this.clockType = Clockable.ClockType.createClocked(this::runOnClock);
    }

    /**
     * Factory method mirroring {@link #ProcessingClockState(Supplier, BiFunction)}.
     *
     * @param initialInput the supplier for the initial input
     * @param mergingFunction the function used to merge the {@link Long} from the tick
     *                        with the last value from the {@link Publisher} of the
     *                        {@link Flowable} this is used on
     * @param <T> the type of the input values of the resulting {@link FlowStrategy}
     * @param <R> the type of the output values of the resulting {@link FlowStrategy}
     * @return a new instance of {@link ProcessingClockState}
     */
    public static <T extends Object, R extends Object> ProcessingClockState<T, R> create(
            Supplier<T> initialInput,
            BiFunction<Long, T, R> mergingFunction) {
        return new ProcessingClockState<>(initialInput, mergingFunction);
    }

    /**
     * Like {@link #create(Supplier, BiFunction)}, but uses a function which ignores the Long
     * value from the last clock tick and just "replays" the last value received by the
     * {@link Flowable}s {@link Publisher}
     *
     * @param initialInput a supplier for the initial input
     * @param <T> the type of the input and output from the resulting {@link FlowStrategy}
     * @return a new instance of {@link ProcessingClockState}
     */
    public static <T extends Object> ProcessingClockState<T, T> createReplaying(Supplier<T> initialInput) {
        return new ProcessingClockState<>(initialInput, (l, t) -> t);
    }

    @Override
    public FlowStrategy<T, R> getFlowStrategy() {
        return strategy;
    }

    @Override
    public boolean runOnClock(TimeProvider provider) {
        timerPublisher.onNext(provider);
        return true;
    }

    @Override
    public ConcurrencyType getConcurrencyType() {
        return ConcurrencyType.EXTERNAL;
    }

    @Override
    public ClockType getClockType() {
        return clockType;
    }
}
